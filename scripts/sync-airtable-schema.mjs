
// Airtable Schema Sync Script for tickets.ukiahseniorcenter.org
// Automatically fetches the schema of all tables in the base and updates AIRTABLE_SCHEMA.md

import fs from 'fs';
import path from 'path';
import 'dotenv/config';

// The tickets app uses process.env.AIRTABLE_BASE_ID
const BASE_ID = process.env.AIRTABLE_BASE_ID;
const API_KEY = process.env.AIRTABLE_API_KEY;

if (!API_KEY) {
  console.error('‚ùå Error: AIRTABLE_API_KEY not found in .env');
  process.exit(1);
}

if (!BASE_ID) {
  console.error('‚ùå Error: AIRTABLE_BASE_ID not found in .env');
  process.exit(1);
}

async function fetchSchema() {
  console.log(`üîÑ Fetching Airtable schema for Base: ${BASE_ID}...`);
  
  const response = await fetch(`https://api.airtable.com/v0/meta/bases/${BASE_ID}/tables`, {
    headers: {
      'Authorization': `Bearer ${API_KEY}`
    }
  });

  if (!response.ok) {
    if (response.status === 403 || response.status === 401) {
       console.error('‚ùå Error: Unauthorized. Your API Token needs "schema.bases:read" scope.');
    }
    throw new Error(`Failed to fetch schema: ${response.status} ${response.statusText}`);
  }

  const data = await response.json();
  return data.tables;
}

function generateMarkdown(tables) {
  let md = `# Airtable Schema: Tickets Base (${BASE_ID})\n\n`;
  md += `> **Last Updated:** ${new Date().toLocaleString()}\n`;
  md += `> **Auto-generated by:** \`scripts/sync-airtable-schema.mjs\`\n\n`;

  // Table of Contents
  md += `## Tables\n`;
  tables.forEach(t => {
    md += `- [${t.name}](#${t.name.toLowerCase().replace(/[^a-z0-9]/g, '-')}) (\`${t.id}\`)\n`;
  });
  md += `\n---\n\n`;

  // Detailed Tables
  tables.forEach(table => {
    md += `### ${table.name}\n`;
    md += `**ID:** \`${table.id}\`  \n`;
    md += `**Description:** ${table.description || 'No description provided'}\n\n`;
    
    md += `| Field Name | Type | ID | Options |\n`;
    md += `|---|---|---|---|\n`;
    
    table.fields.forEach(f => {
      let options = '';
      if (f.options) {
        if (f.options.choices) {
          options = f.options.choices.map(c => `\`${c.name}\``).join(', ');
        } else if (f.options.linkedTableId) {
          const linkedTable = tables.find(t => t.id === f.options.linkedTableId);
          options = `Linked to: **${linkedTable ? linkedTable.name : f.options.linkedTableId}**`;
        } else if (f.type === 'formula') {
            options = `Formula: \`${f.options.formula}\``;
        }
      }
      // Truncate long options
      if (options.length > 100) options = options.substring(0, 97) + '...';
      
      md += `| **${f.name}** | \`${f.type}\` | \`${f.id}\` | ${options} |\n`;
    });
    md += `\n`;
  });

  return md;
}

async function main() {
  try {
    const tables = await fetchSchema();
    const markdown = generateMarkdown(tables);
    
    const outputPath = path.join(process.cwd(), 'AIRTABLE_SCHEMA.md');
    fs.writeFileSync(outputPath, markdown);
    
    console.log(`‚úÖ Schema successfully written to ${outputPath}`);
    console.log(`   Found ${tables.length} tables.`);
  } catch (error) {
    console.error('‚ùå Sync failed:', error.message);
    process.exit(1);
  }
}

main();
